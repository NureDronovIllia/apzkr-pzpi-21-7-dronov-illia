Міністерство освіти та науки України  
Харківський національний університет радіоелектроніки




Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система автоматизації контролю відпуску і заправки транспортних засобів.


Студент гр. ПЗПІ-21-7
	__________________ Дронов І. О.
(підпис)
	Керівник роботи
	__________________  ст.викл. Сокорчук І.П.
(підпис)
	

	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
	Комісія:
	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)
	

Харків 
2024 р.
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук         Кафедра програмної інженерії              
Спеціальність 121 – Інженерія програмного забезпечення        
Курс           3        Семестр                                      6                                ____        
Навчальна дисципліна Архітектура програмного забезпечення        


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Дронову Іллі Олександровичу
1. Тема роботи: «Програмна система автоматизації контролю відпуску і заправки транспортних засобів»        
2. Термін узгодження завдання курсової роботи «01» квітня 2024 р.
3. Термін здачі студентом закінченої роботи «08» червня 2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити:
унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, пітримка інтернаціоналізації, локалізація, забезпечення конфіденційності та адміністрування системи, реалізація чотирьох компонентів (Back-end, Front-end, Mobile app, IoT)        
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки        
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram        






КАЛЕНДАРНИЙ ПЛАН




Номер
	Назва етапів курсової роботи
	Строк виконання етапів роботи
	Примітки
	1
	Функціональна специфікація
програмного проєкту
	15.04.24 — 20.04.24
	

	2
	Проєктування програмного
проєкту
	20.04.24 — 23.04.24
	

	3
	Кодування програмного проєкту
	23.04.24 — 30.05.24
	

	4
	Оформлення пояснювальної
записки
	30.05.24 — 05.06.24
	

	5
	Захист курсової роботи
	05.06.24 — 24.06.24
	

	

Дата видачі завдання «01» квітня 2024 р.
Керівник
	__________________ ст.викл. Сокорчук І.П.
(підпис)
	

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-7
	                
  

Дронов І. О.


(підпис)




	





РЕФЕРАТ



Пояснювальна записка до курсової роботи: 78 с., 24 рис., 2 табл., 3 додатки, 5 джерел.
ТРАНСПОРТНИЙ ЗАСІБ, АДМІНІСТРАТОР, КЛІЄНТ, ПАЛИВО, ЗАПРАВКА, МІСЦЕЗНАХОДЖЕННЯ, ЗМІНА, ЗАПРАВКА, ПРОГРАМНА СИСТЕМА.
Об’єктом дослідження курсової роботи є ринок автоматизації технологічних процесів, а саме актуальне сьогодні питання контролю відпуску палива і заправки транспортних засобів, впровадження автоматизованих систем обліку, моніторингу та управління, а також інтеграція смарт пристроїв для підвищення ефективності та надійності операцій.
Мета курсової роботи полягає в створенні ефективної та надійної системи, яка автоматизує процеси контролю відпуску палива та заправки транспортних засобів, що дозволить підвищити продуктивність, зменшити витрати і забезпечити точність та прозорість операцій. Програма автоматизує облік, моніторинг і управління всіма аспектами, пов'язаними з заправкою, мінімізуючи людські помилки і забезпечуючи своєчасне отримання даних для прийняття обґрунтованих рішень.
Методи розробки базуються на фреймворці FastAPI, що використовує мову програмування Python та сервер бази даних PostgreSQL. Смарт пристрій також було розроблемо засобами мови Python.
У результаті роботи було програмну систему для автоматизації контролю відпуску і заправки транспортних засобів. Ця система складається з сервера та смарт-пристрою.


ЗМІСТ
ВСТУП        7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ        9
1.1 Бізнес-вимоги        9
1.1.1 Бізнес-можливості        9
1.1.2 Бізнес-цілі та критерії успіху        10
1.1.3 Потреби клієнтів або риинку        11
1.1.4 Бізнес-ризики        11
1.2 Концепція рішення        12
1.2.1 Окреслення концепції        12
1.2.2 Головна функціональність        14
1.2.3 Припущення та залежності        14
1.3 Рамки та обмеження проєкту        15
1.3.1 Рамки первинного випуску        15
1.3.2 Рамки наступних випусків        17
1.3.3 Обмеження та винятки        18
1.4 Бізнес-контекст        19
1.4.1 Профілі зацікавлених сторін        19
1.4.2 Пріоритети проєкту        20
1.4.3 Робоче середовище        21
2 ПОСТАНОВКА ЗАДАЧІ        22
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ        24
3.1 Побудова ER-діаграми        24
3.2 Побудова логічної моделі бази даних на основі ER-діаграми        25
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ        29
4.1 Архітектури серверної частини        29
4.2 Архітектура IoT частини        33
5 ОПИС ПРОГРАМНОЇ РЕАЛІЗАЦІЇ        37
5.1 Виклик і завантаження        37
5.2 Призначення і логічна структура        37
5.3 Опис програмної реалізації        38
ВИСНОВКИ        47
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ        48
Додаток А Програмний код серверної частини        49
Додаток Б Програмний код IoT пристрою        73






________________


ВСТУП




У сучасній швидкозростаючій транспортній індустрії ефективне управління споживанням палива та використанням автотранспортних засобів є критичним аспектом для підприємств, що прагнуть оптимізувати свою діяльність. Ручні методи ведення обліку видачі палива та заправки автотранспортних засобів не лише є витратними за часом, але й схильними до помилок та порушень безпеки. Розпізнавши ці виклики, запропонований проєкт спрямований на розробку комплексної програмної системи, призначеної для автоматизації моніторингу та контролю процесів видачі палива та заправки автотранспортних засобів.
        Розроблювальна програмна система відповідатиме потребі у спрощених механізмах звітності, дозволяючи зацікавленим сторонам отримувати доступ до реального часу у відношенні споживання палива, заправних операцій та звітів про використання транспортних засобів. Вона буде забезпечувати широкий спектр звітів та аналітичних даних, необхідних для прийняття обґрунтованих управлінських рішень щодо оптимізації ресурсів та виконання бізнес-потреб.
        З огляду на вимоги щодо безпеки, велика увага приділятиметься захисту конфіденційності даних, забезпеченню захисту від несанкціонованого доступу та запобіганню можливих загроз для інтегрованої системи. Розроблений проєкт буде враховувати сучасні методи шифрування та автентифікації, забезпечуючи безпеку та надійність усіх обмінів інформацією. Такий підхід дозволить мінімізувати ризики витоку даних та забезпечить безпечну та конфіденційну обробку інформації про паливні запаси та транспортні засоби.
        Окрім того, важливим аспектом проекту буде використання інтернаціоналізації та локалізації для забезпечення гнучкості та доступності програмної системи для користувачів з різних країн та мовних середовищ. Це дозволить забезпечити зручний та зрозумілий інтерфейс для всіх користувачів незалежно від їхнього мовного фону, що підвищить ефективність використання системи та зменшить ризик помилок при взаємодії з нею.










































1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості




Серед головних конкурентів у цьому сегменті можна виділити такі компанії, як FuelMaster та FeelTrack.
FuelMaster вже має значний досвід у розробці програмного забезпечення для автоматизації управління паливом та транспортними засобами. Вони пропонують комплексні рішення зі звітності та моніторингу, проте їх система не завжди відповідає всім потребам клієнтів у сфері безпеки та гнучкості. FuelMaster зосереджується переважно на аспектах ефективності та зручності використання, пропонуючи прості інтерфейси та стандартні функції, але не завжди враховує специфічні потреби різних видів транспорту та підприємств. Компанія активно працює в країнах Європи, Північної Америки та Азії;
        FleetTrack спеціалізується на розробці програмних рішень для управління автопарком. Вони пропонують інтегровані системи з моніторингу та аналітики, але їхні рішення не завжди враховують всі аспекти контролю відпуску палива та заправки транспортних засобів. FleetTrack зазвичай зосереджується на відстеженні руху автопарку та витрат пального, але не надає повноцінного інструментарію для контролю за самими процесами заправки та відпуску палива. Послуги компанії доступні споживачам в Північній Америці та Європи.
Зважаючи на системи конкурентів, можна виділити відмінності та переваги нашого проєкту:
        –        проєкт орієнтований на глобальний ринок;
        –        наявність гнучкої системи обробки даних та їх подальшого         аналізу;
        –        наш сервіс передбачає адмін-панель для управління         користувачами та даними системи, що може бути корисним для         підприємців;
        –        більшість конкурентів орієнтовані на ринок США та деякі країни           Європи, в той час як наш сервіс буде надавати послуги по всьому світу.




1.1.2 Бізнес-цілі та критерії успіху




БЦ-1: Забезпечити зростання обсягу замовлень: Досягти збільшення кількості замовлень на 20% протягом першого року роботи програмної системи для автоматизації та контролю служби таксі.
БЦ-2: Забезпечити підвищення задоволеності клієнтів: Досягти 90% задоволеності користувачів системи, виміряної на основі відгуків і оцінок, протягом перших шести місяців використання.
БЦ-3: Розширити географічне охоплення: Охопити щонайменше два нових регіони та забезпечити доступність системи для пасажирів та водіїв в цих регіонах протягом перших двох років роботи продукту.
КУ-1: Кількість підприємців: Зареєструвати не менше ніж 5 тисяч активних бізнесів та 200 000 робітників всередині цих підприємств.
КУ-2: Підвищення прибутковості: Забезпечити збільшення чистого прибутку компанії на 30% протягом перших двох років використання програми.
КУ-3: Покращення функціоналу: Запровадити не менше п'яти нових функцій та можливостей в системі протягом перших двох років, які покращать зручність та продуктивність користувачів та підприємців.
1.1.3 Потреби клієнтів або риинку




        У нашої системи є два основні види користувачів: бізнес та його робітники.
        Потреби бізнесу:
        –        швидкість та простота налаштування системи;
        –        масштабованість системи;
        –        надійність та безпека даних;
        –        ефективність управління ресурсами.


Потреби робітників бізнесу:
–        зручний та простий користувацький інтерфейс, сумісний з будь-якими типами пристроїв;
        –        доступність потрібної для роботи інформації;
        –        наявність функцій для чіткого виконання своїх робочих         обов’язків;
–         наявність системи навчальних довідок для швидкого і ефективного         навчання нових робітників.




1.1.4 Бізнес-ризики


Конкурентний тиск:
        –        Ризик: Зміна конкурентної ситуації на ринку або виникнення         нових конкурентів може призвести до втрати частки ринку та зниження         прибутковості бізнесу;
        –        Рішення: Проведення аналізу конкурентного середовища та         реакція на зміни шляхом вдосконалення продукту або стратегії         маркетингу; забезпечення постійного вдосконалення продукту та         надання переваг перед конкурентами.


        Залежність від постачальників:
        –        Ризик: Зміни в ціновій політиці постачальників та можливість         недостатнього постачання палива можуть призвести до високих витрат,         порушення роботи транспортних засобів та загрози для прибутковості;
        –        Рішення: укладення довгострокових контрактів з надійними         постачальниками для стабілізації цін та забезпечення надійного         постачання; регулярний аналіз ринкових тенденцій та диверсифікація         джерел постачання для зменшення ризиків.


        Технічні проблеми:
        –        Ризик: Виникнення технічних неполадок може призвести до         недієздатності системи;
        –        Рішення: Проведення регулярного технічного обслуговування         паливних компонентів системи, а також створення резервних копій         даних.




1.2 Концепція рішення
1.2.1 Окреслення концепції




Розроблювальний проєкт має на меті створення інноваційної програмної системи для автоматизації контролю відпуску та заправки транспортних засобів. Ця система спрямована на покращення якості обслуговування для операторів та адміністраторів, забезпечуючи зручність, безпеку та ефективність у кожному етапі роботи з технікою.
Головною метою системи є оптимізація процесу контролю та управління технікою, роблячи його максимально простим та зручним для кожного користувача. Ми прагнемо надати зручний інтерфейс для операторів, який дозволить їм легко та швидко контролювати стан обладнання та робити свої обов'язки ефективно.
Важливим аспектом є також забезпечення безпеки для всіх сторін. Система включатиме ефективні механізми моніторингу та контролю, що гарантуватиме операторам та адміністраторам високий рівень безпеки під час виконання робіт. Інтеграція технологій, таких як GPS та Wi-Fi модулі, дозволить точно відстежувати місцезнаходження техніки та забезпечить ефективний контроль за її рухом.
Крім того, система надасть можливість контролювати процес заправки техніки, включаючи автоматичне відстеження рівня палива в заправочних баках та своєчасне замовлення нового палива. Це допоможе уникнути перебоїв у роботі та забезпечить неперервну діяльність обладнання.
Розроблювана система надаватиме звітність та аналітику, що дозволить здійснювати об'єктивний аналіз даних щодо використання техніки, роботи співробітників та ефективності процесів управління. Це допоможе підприємствам приймати обгрунтовані рішення щодо оптимізації витрат та підвищення продуктивності.






1.2.2 Головна функціональність




ГФ-1: Єдина екосистема робітників: Забезпечення можливості робітникам відмічати свою активність, таку як початок / закінчення робочої зміни, дозаправку або техогляд техніки.
ГФ-2: Моніторинг та відстеження: Забезпечення можливості адміністраторам та деяким робітникам відстежувати рух або місцеположення техніки на мапі за допомогою GPS.
ГФ-3: Поповнення палива: Автоматична закупівля палива у компанії-партнера за розкладом, або у разі зменшення рівня палива до критичного низького.
ГФ-4: Аналітика та звітність: Надання аналітичних інструментів для власників та адміністраторів бізнесу з можливістю створення звітів щодо використання транспортних засобів, продуктивності, витрат палива та інших важливих показників.
ГФ-5: Забезпечення захисту даних користувачів та транспортних засобів під час всіх етапів використання системи, включаючи зашифровану передачу даних та забезпечення конфіденційності особистих даних.
        ГФ-6: Багатомовний інтерфейс: Користувачі можуть користуватися додатком англійською й українською мовами.




1.2.3 Припущення та залежності




П-1. Адміністратори та робітники матимуть доступ до Інтернету, оскільки програмна система буде заснована на зв'язку через мобільну мережу або Wi-Fi.
П-2. Значна частина цільової аудиторії користується смартфонами для доступу до програм та послуг, що пропонуються через мобільні додатки.
П-3. Інтеграція системи передбачає можливість співпраці з компаніями-постачальниками палива для його ефективного обігу в середині підприємства
П-4. Користувачі програмної системи мають базові навички роботи з сучасними мобільними пристроями та комп'ютерами для використання основних функцій додатку.
З-1. Реалізація проєкту буде залежати від доступності і надійності технічних ресурсів, таких як сервери, бази даних, мобільні платформи і т. д.
З-2. Успіх системи буде відчутно залежати від активності і прийняття її користувачами, як власниками бізнесів, так і робітниками.
З-3. Інтеграція зовнішніх сервісів, таких як системи оплати або сервіси мапування, буде необхідною для повного функціонування системи.




1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску




Серверна (back-end) частина повинна включати:
* реєстрацію та авторизацію користувачів: реалізація системи користувачів та механізмів входу з підтримкою ролей та прав доступу;
* збереження даних: Зберігання та керування даними про робітників, техніку, паливо, а також аналітичні дані;
* замовлення палива: Розробка алгоритмів для своєчасного дозамовлення палива для безперебійної роботи підприємства;
* моніторинг робітників: Можливість відстежування місцеположення робітників підприємства для моніторингу ефективності праці;
* формування статистики: Можливість формування щоденної статистики по використанню палива.


        IoT частина повинна включати:
* GPS-трекінг: Інтеграція GPS-трекерів в техніці для відстежування її поточного місцеположення;
* Wi-fi модуль: Наявність wi-fi модулів для передачі даних с датчика на сервер для їх подальшої обробки.
* Датчик рівня палива: Інтеграція датчиків палива в цистерни для моніторингу і формування аналітичних даних.
        Front-end частина повинна включати:
* реєстрація та вхід користувачів: сторінки авторизації та реєстрації;
* локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, англійських  та американських систем мір, порядку сортування текстових значень, різного напряму введення тексту;
* адмін-панель: панель, що дозволяє управління користувачами системи, управління  даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань;


        Мобільна частина повинна включати:
* реєстрація та вхід користувачів: сторінки авторизації та реєстрації;
* зміна статусу техніки: надання можливості робітникам змінювати статус наявності на підприємстві техніки (заправка, початок зміни, закінчення зміни тощо);
* локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, англійських  та американських систем мір, порядку сортування текстових значень, різного напряму введення тексту.




1.3.2 Рамки наступних випусків
        


Серверна (back-end) частина може включати:
* Розвиток алгоритмів моніторингу та аналізу даних для виявлення шаблонів у використанні транспортних засобів та оптимізації процесів.
* Розширення функціоналу API для взаємодії з іншими системами та сервісами, зокрема з системами управління запасами та обліку витрат.


        IoT частина може включати:
* інтеграція з електронікою техніки: Зчитування даних з  електроніки, наприклад, поточний стан техніки.
* Впровадження системи моніторингу температури та стану обладнання для попередження можливих поломок.


        Front-end частина може включати:
* підтримка інших мов та регіонів: розширення переліку підтримуваних мов та регіональних налаштувань для приваблення більшої аудиторії;
* Покращення інтерфейсу користувача для полегшення навігації та забезпечення кращого досвіду використання.


        Мобільна частина може включати:
* Реалізацію функції геолокації для визначення місцезнаходження транспортного засобу під час поїздки.
* Додавання функцій сповіщення для інформування користувачів про стан їх транспортного засобу та необхідність обслуговування.




1.3.3 Обмеження та винятки




Обмеження:
* технічні обмеження: Система може не працювати на старих або несумісних пристроях. Користувачі повинні мати сучасний смартфон або комп'ютер для доступу до системи.
* Інтернет-покриття: Для користування системою потрібний доступ до Інтернету. Робітники та адміністратори повинні мати стабільне підключення до мережі.
* залежність від сторонніх служб: Система може бути залежною від сторонніх служб або компаній, таких як картографічні сервіси або постачальники палива, і може стикатися із проблемами в разі недоступності цих служб.
* зміна тарифів і комісій: Зміни в тарифах і комісіях, встановлених постачальниками палива, можуть вплинути на вартість послуг і прибуток.


Винятки:
* аварійні ситуації: Винятком є аварійні ситуації, такі як надзвичайні обставини, стихійні лиха або інші подібні події, які можуть призвести до неможливості функціонування підприємства і, як наслідок, програмної системи;
* технічні проблеми: Винятком є технічні проблеми, які можуть вплинути на доступність системи, такі як відмова серверів, атаки злому, віруси тощо;
* надзвичайні обставини: Винятком є надзвичайні обставини, такі як війни, карантини, епідемії тощо, які можуть вплинути на нормальне функціонування системи.




1.4 Бізнес-контекст 
1.4.1 Профілі зацікавлених сторін




Профілі зацікавлених сторін проєкту наведені в таблиці 1.1


Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона
	Головна цінність
	Ставлення
	Головний інтерес
	Обмеження
	Бізнес
	Збільшення доходів, оптимізація витрат
	Інтерес в прибутковості проєкту
	Підвищення прибутковості, розширення клієнтської бази
	Фінансові обмеження, конкуренція на ринку
	Звичайні користувачі
	Зручність, доступність, надійність
	Очікування зручного та надійного сервісу
	Ефектнивний контроль відпуску та заправки техніки
	Проблеми з доступністю смартфонів або Інтернету
	Розробник проєкту
	Розробка та підтримка програмного продукту
	Інтерес в розробці та вдосконаленні ПЗ
	Удосконалення та підтримка програмного продукту
	Обмежені ресурси для розробки, технічні обмеження
	Інвестори
	Прибуток, зростання цінності інвестицій, успіх проєкту


	Очікування високої рентабельності
	Збільшення вартості інвестицій, отримання прибутку
	Фінансові ризики, ринкові коливання
	







1.4.2 Пріоритети проєкту




        Пріоритети проєкту наведені в таблиці 1.2


Таблиця 1.2 – Пріоритети проєкту
Показник
	Виконання (етапи)
	Обмеження (граничні значення)
	Ступінь свободи (допустимий діапазон)
	План робіт
	Продукт має бути випущеним до 08.06.2024
	

	Можливе відхилення від графіку на 1-2 місяці
	Функціональність
	

	

	90% функціоналу має працювати на релізі 1.0
	Якість
	

	

	У релізі 1.0 повинні пройти 100% тестувань
	Персонал
	

	Максимальний розмір команди – один розробник та адміністратор
	Персонал
	Ціна
	

	7000 гривень
	Допустиме відхилення на 15-20%
	

1.4.3 Робоче середовище




Системою зможуть користуватися люди з будь-якої країни. Користувачі повинні мати безперервний доступ до системи. Це буде досягнуто завдяки хмарним сервісам Amazon Web Services.
Також важливо розширити доступність додатку завдяки локалізації (українська та англійська мови) та інтернаціоналізації (міри ваги, довжини тощо). 
Оскільки застосунок працюватиме в різних країнах, важливо врахувати різницю в часових поясах та представленні часу.
Дані будуть зберігатися в базі даних PostgreSQL. Доступ до даних здійснюватиметься за допомогою бібліотеки SQLAlchemy.
Для розробки серверної частини буде використано технології FastAPI, що використовує мову програмування Python. Середовищем розробки буде Visual Studio Code.
Захист даних користувачів повинен бути забезпечений згідно GDPR.
Для розробки IoT частини буде використовуватися Arduino. Середовищем розробки буде Arduino IDE, інтегроване середовище розробки, яке дозволяє легко програмувати мікроконтролери Arduino за допомогою мови програмування C++. Також на Arduino буде встановлено датчик руху, GPS, спідометр та Wi-Fi модулі.
Для розробки веб-застосунку буде використано бібліотеку React.js. Середовищем розробки буде Visual Studio Code.
Для розробки мобільної частини буде використано мову програмування Kotlin. Середовищем розробки буде IntelliJ IDEA.
2 ПОСТАНОВКА ЗАДАЧІ




        За результатами попереднього аналізу предметної області, основним завданням курсової роботи було визначено створення програмної системи для автоматизації контролю відпуску палива та заправки транспортних засобів.
База даних цієї системи повинна містити інформацію про постачальників палива, резервуари з паливом, замовлення, користувачів, робочі зміни, транспортні засоби, інспекції та статуси.
        Для робітників має бути реалізований наступний функціонал:
* вхід в систему;
* початок / закінчення робочої зміни;
* заправка транспортного засобу;
* обслуговування транспортного засобу.
Для адміністраторів системи має бути реалізований такий функціонал:
* реєстрація та вхід у систему;
* керування користувачами системи;
* перегляд, додавання, видалення сутностей у базі даних;
* моніторинг рівня палива у сховищах на підприємстві;
* закупівля палива;
* експорт даних системи.
Крім того, програмна система повинна підтримувати локалізацію та інтернаціоналізацію, зокрема: підтримку різних кодувань символів, обчислення та форматування дати та часу, відображення локального та універсального часу, використання метричних одиниць вимірювання та англо-американської системи мір, правильне сортування текстових значень, різні напрямки введення тексту та інше.
        
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми




        На основі аналізу предметної області були визначені основні сутності та встановлені зв’язки між ними, Вони були представлені у вигляді ER-діаграми. (див. рис. 3.1).


  

Рисунок 3.1 – ER-діаграма бази даних


У базі даних наявні наступні зв’язки між сутностями:
* постачальник / сховище палива  та замовлення мають зв’язок один до багатьох, бо в одному замовленні може брати участь тільки один постачальник / сховище;
* користувач та замовлення мають зв’язок один до багатьох, бо користувач може робити багато замовлень;
* користувач та інспекція мають зв’язок один до багатьох, бо один користувач може проводити багато інспекцій;
* користувач та зміна мають зв’язок один до багатьох, бо один користувач може виходити на багато змін;
* транспортний засіб та інспекція мають зв’язок один до багатьох, бо один транспортний засіб може приймати участь у багатьох інспекціях;
* транспортний засіб та зміна мають зв’язок один до багатьох, бо один транспортний засіб може бути використаних на багатьох змінах;
* транспортний засіб та статус мають зв’язок один до багатьох, бо один транспортний засіб може мати багато статусів.




3.2 Побудова логічної моделі бази даних на основі ER-діаграми




        У логічній моделі БД представлені наступні сутності:
* сховища палива (fuel_storages);
* постачальники палива (fuel_suppliers);
* покупки (purchases);
* користувачі (users);
* робочі зміни (shifts);
* інспекції (inspections);
* транспортні засоби (vehicles);
* статуси (statuses).


Створимо таблицю сховищ палива (fuel_storages). Вона буде такі поля: id (первинний ключ), max_amount, current_amount, critical_amount, fuel_type.
Перевіримо таблицю fuel_storages на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.


Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю постачальників палива (fuel_suppliers). Вона буде такі поля: id (первинний ключ), title, price, fuel_type. Перевіримо таблицю fuel_suppliers на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.
Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю закупівель (purchases). Вона буде такі поля: id (первинний ключ), fuel_storage_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею fuel_storages), fuel_supplier_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею fuel_suppliers), user_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею users),  amount, created_at.
Перевіримо таблицю purchases на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.


Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю користувачів (users). Вона буде такі поля: id (первинний ключ), first_name, last_name, birth_date, gender, role, email, password, passport_number, registered_at.
Перевіримо таблицю users на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.


Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю інспекцій (inspections). Вона буде такі поля: id (первинний ключ), vehicle_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею vehicles), user_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею users), reason, conclusion, start_time, end_time.
Перевіримо таблицю inspections на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.
Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю робочих змін (shifts). Вона буде такі поля: id (первинний ключ), vehicle_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею vehicles), user_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею users), start_time, end_time.
Перевіримо таблицю shifts на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.
Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю транспортних засобів (vehicles). Вона буде такі поля: id (первинний ключ), type, title, current_fuel_lvl, max_fuel_lvl, current_lng, current_lat.
Перевіримо таблицю vehicles на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.


Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
Створимо таблицю статусів (statuses). Вона буде такі поля: id (первинний ключ), vehicle_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею vehicles), title, created_at.
Перевіримо таблицю statuses на відповідність нормалізації:
* Усі атрибути атомарні: містять лише одне значення і не є множинами.
* Дані не повторюються.
* Усі неключові атрибути залежать від первинного ключа.
Таким чином, таблиця відповідає першій, другій і третій нормальній формі.
В результаті проектування таблиць та зв'язків майбутньої бази даних була створена її логічна схема (див. рис. 3.2).


  

Рисунок 3.2 – Логічна схема бази даних


Оскільки всі таблиці в представленій логічній схемі бази даних перебувають у третій нормальній формі, можна зробити висновок, що сама база даних також знаходиться у третій нормальній формі.
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
        4.1 Архітектури серверної частини
        
        
Користувачами розробленої системи є 2 типи акторів: працівник та адміністратор. 
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).


  

Рисунок 4.1 – Діаграма прецендентів серверної частини


Для написання серверної частини системи було обрано мову програмування Python з використанням веб-фреймворку FastAPI.
У якості бази даних використано PostgreSQL, до якої з серверного застосунка здійснюється доступ за допомогою технології SQLAlchemy, що надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей.
        Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).


  

Рисунок 4.2 – Діаграма розгортання серверної частини


Для демонстрації та тестування API застосовується OpenApi (Swagger), що забезпечує зручне тестування та документацію API, підвищуючи якість і зручність розробки. 
Для гарантування безпеки даних і конфіденційності використовується протокол HTTPS, який захищає дані під час їхньої передачі. 
Для реалізації автентифікації та авторизації застосовується бібліотека pyjwt, яка надає простий і зручний спосіб створення, підписування та перевірки JWT, що дозволяє легко інтегрувати автентифікацію та авторизацію в додатках.


        
Для керування маршрутизацією запитів у FastAPI використовуються вбудовані API роутери (контролери). Вони дають змогу структурувати програму на окремі логічні компоненти, кожен з яких відповідає за обробку певних типів запитів або користувацьких дій. Це сприяє більш зручному управлінню кодом та його подальшому розширенню.
Для організації серверного застосунка було використано шаблон MVC (Model-view-controller). Таким чином, додаток складається з таких частин:
        Для організації серверного застосунка було використано шаблон MVC (Model-View-Controller). Додаток складається з трьох частин: Model, яка відповідає за управління даними та бізнес-логікою, взаємодіє з базою даних і обробляє необхідні операції; View, що займається представленням даних користувачеві, відображаючи їх у зрозумілому вигляді та забезпечуючи користувацький інтерфейс; Controller, який служить посередником між моделлю та видом, обробляє вхідні запити, викликає відповідні методи моделі для обробки даних і передає результати у View для відображення. Така структура чітко розмежовує обов'язки різних частин додатка, спрощує його розробку, тестування та підтримку, сприяє гнучкості та масштабованості архітектури, оскільки зміни в одному компоненті не впливають безпосередньо на інші, що полегшує внесення змін і розширення функціональності.
Архітектура серверного застосунка представлена на діаграмі пакетів (див. рис. 4.3).        






  

Рисунок 4.3 – Діаграма пакетів серверної частини


        Приклади програмного коду серверної частини наведено у додатку А.
        Отже, було визначено архітектуру та технології серверної частини програмної системи.
















4.2 Архітектура IoT частини




IoT частини розробленої системи взаємодіє з одним типом користувачів, а саме з адміністраторами. Пристрій відправляє дані з датчиків рівня палива. Адміністратор може переглядати ці дані у режимі реального часу. Крім того, якщо рівень палива у сховищі опуститься нижче критично допустимого, адміністратору буде надіслано повідомлення про те, що це сховище потребує закупівлі палива.
Взаємодія користувача з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4).


  

Рисунок 4.4 – Діаграма прецендентів IoT частини програмної системи


Для демонстрації функціональних можливостей розумного пристрою системи моніторингу рівня палива у сховищах реалізовано на мові програмування Python. Програмна реалізація буде максимально наближена до пристроїв RaspberryPi, які можуть запускати програми на Python. 
В програмному забезпечені дані надсилаються за допомогою бібліотеку
requests, у форматі JSON.
Програмне забезпечення структуроване на модулі, кожен з яких
відповідає за певну функціональність (приклади коду див. додат. Б):
* main.py: головний модуль для запуску пристрою для подальшої демонстрації програмної реалізації;
* auth.py: модуль для авторизації та аутентифікації пристрою для отримання jwt-токена, потрібного для проведення демонстраційних операцій;
* api_fetch.py: модуль для взаємодією з бізнес-логікою backend-додатку;
* config.py: модуль для маніпулювання локальними даними iot-пристрою;
* services: модуль з бізнес логікою iot-пристрою;


Для написання програмної реалізації Iot пристрою було обрано мову Python. Її було обрано за простоту використання, велике різноманіття бібліотек та придатність для обробки та аналізу даних.
        Для шифрування та розшифрування даних у форматі JSON було використано однойменну бібліотеку json. Сама програма складається з одного основного модуля та трьох допоміжних. Для більш детальної візуалізації архітектури та використаних технологій було розроблено діаграму пакетів (див. рис. 4.5).






                                        
  

Рисунок 4.5 – Діаграма пакетів IoT частини програмної системи
Для більш детальної візуалізації взаємодії пристрою з користувачами системи було розроблено діаграму взаємодії (див. рис. 4.6).
  

Рисунок 4.6 – Діаграма взаємодії IoT частини програмної системи
Також на основі взаємодії пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7).


  

Рисунок 4.7 – Діаграма діяльності IoT частини програмної системи
Таким чином, за допомогою діаграм пакетів, взаємодії та діяльності було визначено основні технології та архітектуру системи.
5 ОПИС ПРОГРАМНОЇ РЕАЛІЗАЦІЇ
5.1 Виклик і завантаження




Щоб почати використовувати програмну систему, необхідно спершу розгорнути її серверну частину. Для кросплатформного розгортання застосовується контейнеризація, а саме: Docker та Docker Compose. Спочатку необхідно завантажити Docker CLI і його розширення Docker Compose, або Docker Engine з офіційного сайту або з системних репозиторіїв, якщо ви використовуєте операційну систему Linux або MacOS. Після цього потрібно завантажити архів з останньою версією серверної частини, перейти до каталогу з ним і ввести команду «docker compose up» у термінал. 
Після успішного запуску сервер буде доступний за локальною IP-адресою (localhost:8000).
Для запуску IoT частини потрібно зайти в головну директорію та  запустити головний файл додатку, використавши команду «python main.py» (або python3, в залежності від вашої операційної системи).




5.2 Призначення і логічна структура




Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
* адміністратори;
* працівники;
* авторизація та реєстрація;
* дані системи;
* паливо;
Модуль «Адміністратори» містить у собі функціонал призначений для адміністраторів, а саме: додавання, редагування та видалення користувачів до бази даних.
Модуль «Працівники» надає функціонал, призначений для працівників підприємств. Управління та моніторинг робочих змін, зміна статусу транспортних засобів.
Модуль «Авторизація та реєстрація» надає функціонал адміністраторам та працівникам створення нових облікових записів та їх використання для автентифікації у систему за допомогою логіну (пошти) та пароля.
Модуль «Дані системи» призначений для адміністраторів і дозволяє їм маніпулювати сутностями у базі даних системи (додавання, видалення, редагування).
Модуль «Паливо» є суміжним модулем для адміністраторів та працівників. З боку адміністраторів він надає функціонал моніторингу кількості палива на підприємстві і його закупівлі. Працівникам надається можливість заправляти свої транспортні засоби під час робочих змін.




5.3 Опис програмної реалізації




При відкритті програми можна побачити доступні кінцеві точки (див. рис. 5.1)


  

Рисунок 5.1 – Доступні для використання кінцеві точки


        Авторизуємося з акаунта адміністратора для демонстрації наявного функціоналу (див. рис. 5.2)
  

Рисунок 5.2 – Екран авторизації з акаунта адміністратора


        Далі отриманий JWT токен використовується майже в усіх запитах для валідації. 
        Створимо акаунт працівника для подальшої демонстрації наявного функціоналу (див. рис. 5.3).
  

Рисунок 5.3 – Екран створення акаунта працівника


        Адміністратору системи наданий доступ до більшості  функціоналу.  Це включає перегляд, додавання, видалення та редагування даних користувачів та інших сутностей бази даних (див рис. 5.4, 5.5). 
  

Рисунок 5.5 – Перегляд даних наявних на підприємстві транспортних засобів


  

Рисунок 5.6 – Додавання нового транспортного засобу


Крім того, в обов’язки адміністратора входить моніторинг та закупівля палива для підприємтсва (див. рис. 5.6), для чого існує функціонал критичних повідомлень. Вони приходять с IoT пристрою (датчику рівня палива), якщо рівень палива у резервуарі досягає критичного (див. рис. 5.7). 
  

Рисунок 5.6 – Перегляд даних про сховища палива




  

Рисунок 5.7 – Екран з критичними повідомленнями


        Після отримання такого повідомлення адміністратор повинен докупити паливо для цього резервуару (див. рис. 5.8). Під час цієї операції обирається потрібний резервуар, постачальник палива та потрібна кількість. 
  

Рисунок 5.8 – Операція закупівлі палива


        У обов’язки працівників входить вихід на робочу зміну та обслуговування транспортних засобів підприємтсва.
        Перед виконанням будь якої операції працівнику потрібно авторизуватися у системі (див. рис. 5.9).


  

Рисунок 5.9 – Екран авторизації працивника підприємтсва.


        Для позначання виходу на робочу зміну працівнику необхідно скористуватись відведеним під це ендпоінтом (див. рис. 5.10).
  

Рисунок 5.10 – Екран початку робочої зміни працівника


        Під час робочої зміни у працівника є декілька варіантів обслуговування транспортного засобу. Це або заправка (див. рис. 5.11, 5.12), або інспекція (див. рис. 5.13, 5.14). Заправка ТЗ відбувається по факту недостатньої кількості пального у баках. Інспекції можуть буди або планові, або позапланові (по факту надзвичайної ситуації).


  

Рисунок 5.11 – Екран початку заправки ТЗ


  

Рисунок 5.12 – Екран завершення заправки ТЗ




  

Рисунок 5.13 – Екран початку інспекції ТЗ


  

Рисунок 5.14 – Екран завершення інспекції ТЗ


        В кінці робочої зміни працівник повинен відмітити це у системі(див. рис. 5.15).
  

Рисунок 5.15 – Екран завершення робочої зміни працівника






























ВИСНОВКИ




        За результатами виконання роботи було розроблено програмну систему для автоматизації контролю відпуску та заправки транспортних засобів.
        У процесі роботи було проаналізовано предменту область, спроєктовано логічну та ER схеми БД, розроблено архітектуру серверної та IoT частин програмної системи та реалізовано її засобами фреймворку FastAPI та мови програмування Python.
        Розроблена програмна система призначена для автоматизації контролю відпуску та заправки транспортних засобів. Вона дозволяє відстежувати та реєструвати кожен випадок заправки, забезпечуючи точний облік витрат палива. Система автоматизує процеси, що знижує ймовірність людських помилок і підвищує ефективність управління паливними ресурсами. Крім того, вона надає можливість аналізувати дані про витрати палива, оптимізувати маршрути та зменшувати витрати, що в результаті сприяє підвищенню продуктивності підприємства. До того ж, в системі наявні можливості адміністрування, такі як: керування користувачами системи, керування даними та налаштуваннями системи, експорт та імпорт даних та сертифікатів.














ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ




1. FastAPI framework documentation. URL: https://fastapi.tiangolo.com/ (дата звернення: 21.06.2024).
        2.  PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 21.06.2024).
        3.  Docker Compose overview. Docker compose documentation. URL:
https://docs.docker.com/compose/ (дата звернення: 21.06.2024).
        4. Мартін Р. Чистий Код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
        5. Python documentation. URL: https://docs.python.org/3/
        6. Посилання на демонстрацію: https://youtu.be/tlLScsggg6k?si=3Te4IsR0Kqzlh3R9
        


















Додаток А Програмний код серверної частини
А.1 Код сервісу для транспортних засобів vehicles.py


1  from fastapi import HTTPException, status
2  
3  from app.models.db.shift import Shift
4  from app.models.db.user import User, UserRoles
5  from app.models.db.vehicle import Inspection, Vehicle, VehicleStatuses
6  from app.models.schemas.vehicle import (
7      InspectionBase,
8      InspectionData,
9      InspectionUpdate,
10     RefuelData,
11     SetStatus,
12     VehicleBase,
13     VehicleData,
14     VehicleUpdate,
15 )
16 from app.repository.inspection import InspectionRepository
17 from app.repository.shift import ShiftRepository
18 from app.repository.user import UserRepository
19 from app.repository.vehicle import VehicleRepository
20 from app.services.base import BaseService
21 
22 
23 class VehicleService(BaseService):
24     def __init__(
25         self,
26         user_repository,
27         vehicle_repository,
28         shift_repository,
29         inspection_repository,
30     ) -> None:
31         self.user_repository: UserRepository = user_repository
32         self.vehicle_repository: VehicleRepository = vehicle_repository
33         self.shift_repository: ShiftRepository = shift_repository
34         self.inspection_repository: InspectionRepository = inspection_repository
35 
36     async def _get_vehicles_with_status(
37         self, vehicles: list[Vehicle]
38     ) -> list[VehicleData]:
39         current_statuses: list[str] = [
40             await self.vehicle_repository.get_current_status(vehicle.id)
41             for vehicle in vehicles
42         ]
43 
44         # Unpack main vehicle object and add a status field
45         return [
46             VehicleData(
47                 **vehicle.__dict__,
48                 current_status=VehicleStatuses(status) if status else None,
49             )
50             for vehicle, status in zip(vehicles, current_statuses)
51         ]
52 
53     async def get_vehicles(self, current_user: User) -> list[VehicleData]:
54         await self._validate_user_permissions(self.user_repository, current_user.id)
55 
56         vehicles: list[Vehicle] = await self.vehicle_repository.get_vehicles()
57         return await self._get_vehicles_with_status(vehicles)
58 
59     async def refuel_vehicle(
60         self, vehicle_id: int, data: RefuelData, current_user: User
61     ) -> None:
62         await self._validate_instance_exists(self.vehicle_repository, vehicle_id)
63         await self._validate_user_permissions(
64             self.user_repository, current_user.id, UserRoles.EMPLOYEE
65         )
66 
67         vehicle: Vehicle = await self.vehicle_repository.get_vehicle(vehicle_id)
68         vehicle_status = await self.vehicle_repository.get_current_status(vehicle_id)
69         if vehicle_status in [VehicleStatuses.FUEL, VehicleStatuses.INSPECTION]:
70             raise HTTPException(
71                 status.HTTP_400_BAD_REQUEST,
72                 "You can't refuel this vehicle at the moment",
73             )
74 
75         if vehicle_status != VehicleStatuses.OFF_SHIFT:
76             # Validate if employee can access the vehicle
77             current_shift: Shift = await self.shift_repository.get_current_user_shift(
78                 current_user.id
79             )
80             if not current_shift or current_shift.vehicle_id != data.vehicle_id:
81                 raise HTTPException(status.HTTP_403_FORBIDDEN, detail="Forbidden")
82 
83         allowed_fuel_amount: float = round(
84             vehicle.max_fuel_lvl - vehicle.current_fuel_lvl
85         )
86         if data.amount > allowed_fuel_amount:
87             raise HTTPException(
88                 status.HTTP_400_BAD_REQUEST,
89                 f"You can't put that much fuel in. Maximum permissible value is {allowed_fuel_amount}",
90             )
91 
92         await self.vehicle_repository.set_current_status(
93             vehicle_id, VehicleStatuses.FUEL
94         )
95         vehicle.current_fuel_lvl += data.amount
96         await self.vehicle_repository.save(vehicle)
97 
98     async def stop_refuel(self, vehicle_id: int, current_user: User) -> None:
99         await self._validate_instance_exists(self.vehicle_repository, vehicle_id)
100        await self._validate_user_permissions(
101            self.user_repository, current_user.id, UserRoles.EMPLOYEE
102        )
103 
104        vehicle_status = await self.vehicle_repository.get_current_status(vehicle_id)
105        if vehicle_status != VehicleStatuses.FUEL:
106            raise HTTPException(
107                status.HTTP_400_BAD_REQUEST, "The vehicle is not on a refuel"
108            )
109 
110        # Set status that was before refueling
111        recent_status = await self.vehicle_repository.get_recent_status(vehicle_id)
112        await self.vehicle_repository.set_current_status(recent_status)
113 
114    async def create_vehicle(
115        self, data: VehicleBase, current_user: User
116    ) -> VehicleData:
117        await self._validate_user_permissions(self.user_repository, current_user.id)
118 
119        new_vehicle: Vehicle = await self.vehicle_repository.create_vehicle(data)
120        return (await self._get_vehicles_with_status([new_vehicle]))[0]
121 
122    async def set_current_status(
123        self, vehicle_id: int, status: SetStatus, current_user: User
124    ) -> None:
125        await self._validate_user_permissions(self.user_repository, current_user.id)
126        await self._validate_instance_exists(self.vehicle_repository, vehicle_id)
127 
128        await self.vehicle_repository.set_current_status(vehicle_id, status.status)
129 
130    async def update_vehicle(
131        self, vehicle_id: int, data: VehicleUpdate, current_user: User
132    ) -> VehicleData:
133        await self._validate_user_permissions(self.user_repository, current_user.id)
134        await self._validate_instance_exists(self.vehicle_repository, vehicle_id)
135 
136        updated_vehicle: Vehicle = await self.vehicle_repository.update_vehicle(
137            vehicle_id, data
138        )
139        return (await self._get_vehicles_with_status([updated_vehicle]))[0]
140 
141    async def delete_vehicle(self, vehicle_id: int, current_user: User) -> None:
142        await self._validate_user_permissions(self.user_repository, current_user.id)
143        await self._validate_instance_exists(self.vehicle_repository, vehicle_id)
144 
145        await self.vehicle_repository.delete_vehicle(vehicle_id)
146 
147    async def get_inspections(self, current_user: User) -> list[VehicleData]:
148        await self._validate_user_permissions(self.user_repository, current_user.id)
149 
150        inspections: list[
151            Inspection
152        ] = await self.inspection_repository.get_inspections()
153        return [InspectionData(**inspection.__dict__) for inspection in inspections]
154 
155    async def start_inspection(
156        self, data: InspectionBase, current_user: User
157    ) -> InspectionData:
158        await self._validate_instance_exists(self.vehicle_repository, data.vehicle_id)
159        await self._validate_user_permissions(
160            self.user_repository, current_user.id, UserRoles.EMPLOYEE
161        )
162 
163        # Validate if employee can access the vehicle
164        current_shift: Shift = await self.shift_repository.get_current_user_shift(
165            current_user.id
166        )
167        if not current_shift or current_shift.vehicle_id != data.vehicle_id:
168            raise HTTPException(status.HTTP_403_FORBIDDEN, detail="Forbidden")
169 
170        is_vehicle_on_inspection: bool = (
171            await self.inspection_repository.is_vehicle_on_inspection(data.vehicle_id)
172        )
173        if is_vehicle_on_inspection:
174            raise HTTPException(
175                status.HTTP_400_BAD_REQUEST, "This vehicle is already on inspection"
176            )
177 
178        inspection: Inspection = await self.inspection_repository.create_inspection(
179            data, user_id=current_user.id
180        )
181 
182        await self.vehicle_repository.set_current_status(
183            data.vehicle_id, VehicleStatuses.INSPECTION
184        )
185        return InspectionData(**inspection.__dict__)
186 
187    async def end_inspection(
188        self, inspection_id: int, data: InspectionUpdate, current_user: User
189    ) -> InspectionData:
190        await self._validate_instance_exists(self.inspection_repository, inspection_id)
191        await self._validate_user_permissions(
192            self.user_repository, current_user.id, UserRoles.EMPLOYEE
193        )
194 
195        inspection: Inspection = await self.inspection_repository.get_inspection(
196            inspection_id
197        )
198        if inspection.user_id != current_user.id:
199            raise HTTPException(status.HTTP_403_FORBIDDEN, "Forbidden")
200 
201        if inspection.end_time:
202            raise HTTPException(
203                status.HTTP_400_BAD_REQUEST, "This inspection is already over"
204            )
205 
206        updated_inspection: Inspection = (
207            await self.inspection_repository.update_inspection(inspection_id, data)
208        )
209        await self.vehicle_repository.set_current_status(
210            updated_inspection.vehicle_id, VehicleStatuses.OFF_SHIFT
211        )
212 
213        return InspectionData(**updated_inspection.__dict__)


        А.2 Код сервісу авторизації


1  from datetime import datetime, timedelta
2  from typing import Dict, Optional
3  
4  import jwt
5  from fastapi import HTTPException
6  from fastapi.security import HTTPBearer
7  from passlib.context import CryptContext
8  from starlette import status
9  
10 from app.config.settings.base import settings
11 
12 
13 class AuthHandler:
14     def __init__(self) -> None:
15         self.security = HTTPBearer()
16         self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
17         self.secret: str = settings.JWT_SECRET
18 
19     def get_password_hash(self, password: str) -> str:
20         return self.pwd_context.hash(password)
21 
22     def verify_password(self, plain_password: str, hashed_password: str) -> bool:
23         return self.pwd_context.verify(plain_password, hashed_password, scheme="bcrypt")
24 
25     def encode_token(self, user_id: int, user_email: str) -> str:
26         # Initialize user_crud object to get user id once and put it in jwt payload
27 
28         payload = {
29             "exp": datetime.utcnow() + timedelta(days=30),
30             "iat": datetime.utcnow(),
31             "sub": user_email,
32             "id": user_id,
33         }
34         return jwt.encode(payload, self.secret, algorithm="HS256")
35 
36     async def decode_token(self, token: str) -> Optional[Dict[str, bool]]:
37         try:
38             payload = jwt.decode(token, self.secret, algorithms=["HS256"])
39             return {"email": payload["sub"], "id": payload["id"], "auth0": False}
40         except jwt.ExpiredSignatureError:
41             raise HTTPException(
42                 status.HTTP_401_UNAUTHORIZED, detail="Signature has expired"
43             )
44         except jwt.InvalidTokenError:
45             raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
46 
47 
48 def get_auth_handler() -> AuthHandler:
49     return AuthHandler()
50 
51 
52 auth_handler: AuthHandler = get_auth_handler()


        А.3 Код сервісу користувачів


1  from typing import Any
2  
3  from fastapi import HTTPException, status
4  from sqlalchemy.exc import IntegrityError
5  
6  from app.models.db.user import User, UserRoles
7  from app.models.schemas.users import (
8      PasswordChangeInput,
9      PasswordChangeOutput,
10     UserData,
11     UserLoginInput,
12     UserLoginOutput,
13     UserRegister,
14     UserUpdate,
15 )
16 from app.repository.user import UserRepository
17 from app.securities.authorization.auth_handler import auth_handler
18 from app.services.base import BaseService
19 from app.utilities.formatters.http_error import error_wrapper
20 
21 
22 class UserService(BaseService):
23     def __init__(self, user_repository) -> None:
24         self.user_repository: UserRepository = user_repository
25 
26     async def get_profile(self, current_user) -> UserData:
27         return UserData(**current_user.__dict__)
28 
29     async def register_user(
30         self, user_data: UserRegister, current_user: User
31     ) -> UserData:
32         await self._validate_user_permissions(self.user_repository, current_user.id)
33 
34         # Hashing input password
35         user_data.password = auth_handler.get_password_hash(user_data.password)
36 
37         try:
38             result: User = await self.user_repository.create_user(user_data)
39         except IntegrityError:
40             raise HTTPException(
41                 status.HTTP_409_CONFLICT,
42                 detail=error_wrapper("User with this email already exists", "email"),
43             )
44 
45         return UserData(**result.__dict__)
46 
47     async def authenticate_user(self, user_data: UserLoginInput) -> UserLoginOutput:
48         user_existing_object: User = await self.user_repository.get_user_by_email(
49             user_data.email
50         )
51         if not user_existing_object:
52             raise HTTPException(
53                 status.HTTP_404_NOT_FOUND,
54                 detail="User with this email is not registered in the system",
55             )
56 
57         verify_password = auth_handler.verify_password(
58             user_data.password, user_existing_object.password
59         )
60         if not verify_password:
61             raise HTTPException(
62                 status.HTTP_400_BAD_REQUEST,
63                 detail=error_wrapper("Invalid password", "password"),
64             )
65 
66         auth_token = auth_handler.encode_token(user_existing_object.id, user_data.email)
67         return {"token": auth_token}
68 
69     async def get_users(self, current_user: User) -> list[User]:
70         await self._validate_user_permissions(self.user_repository, current_user.id)
71 
72         users: list[User] = await self.user_repository.get_users()
73         return [UserData(**user.__dict__) for user in users]
74 
75     async def update_user(
76         self, user_id: int, user_data: UserUpdate, current_user: User
77     ) -> UserData:
78         await self._validate_instance_exists(self.user_repository, user_id)
79         if user_id != current_user.id:
80             raise HTTPException(status.HTTP_403_FORBIDDEN, "Forbidden")
81 
82         try:
83             updated_user: User = await self.user_repository.update_user(
84                 user_id, user_data
85             )
86             return UserData(**updated_user.__dict__)
87         except IntegrityError:
88             raise HTTPException(
89                 status.HTTP_409_CONFLICT,
90                 detail=error_wrapper("User with this email already exists", "email"),
91             )
92 
93     async def delete_user(self, user_id: int, current_user: User) -> None:
94         await self._validate_user_permissions(self.user_repository, current_user.id)
95         await self._validate_instance_exists(self.user_repository, user_id)
96         if user_id == current_user.id:
97             raise HTTPException(
98                 status.HTTP_400_BAD_REQUEST,
99                 "You are trying to delete an account you're currently logged in",
100            )
101 
102        await self.user_repository.delete_user(user_id)
103 
104    async def change_password(
105        self, current_user: User, data: PasswordChangeInput
106    ) -> PasswordChangeOutput:
107        # Validate the old password match the current one
108        if not auth_handler.verify_password(data.old_password, current_user.password):
109            raise HTTPException(
110                status.HTTP_400_BAD_REQUEST,
111                detail=error_wrapper("Invalid old password", "old_password"),
112            )
113 
114        # Validate the new password does not match the old password
115        if auth_handler.verify_password(data.new_password, current_user.password):
116            raise HTTPException(
117                status.HTTP_409_CONFLICT, detail="You can't use your old password"
118            )
119 
120        current_user.password = auth_handler.get_password_hash(data.new_password)
121        await self.user_repository.save(current_user)
122 
123        return PasswordChangeOutput(message="The password was successfully reset")
124 
125    async def export_data_xlsx(self, current_user_id: int):
126        await self._validate_user_permissions(self.user_repository, current_user_id)
127        return await self.user_repository.export_data_xlsx()


        А.4 Код сервісу пального


1  from fastapi import HTTPException, status
2  from sqlalchemy.exc import IntegrityError
3  
4  from app.models.db.fuel import FuelStorage, FuelSupplier, Purchase
5  from app.models.db.user import User
6  from app.models.schemas.fuel import (
7      PurchaseBase,
8      PurchaseCreate,
9      PurchaseData,
10     StorageBase,
11     StorageData,
12     StorageUpdate,
13     SupplierBase,
14     SupplierData,
15     SupplierUpdate,
16 )
17 from app.repository.fuel_storage import FuelStorageRepository
18 from app.repository.fuel_supplier import FuelSupplierRepository
19 from app.repository.purchase import PurchaseRepository
20 from app.repository.user import UserRepository
21 from app.services.base import BaseService
22 from app.utilities.formatters.http_error import error_wrapper
23 
24 
25 class FuelService(BaseService):
26     def __init__(
27         self,
28         user_repository,
29         fuel_supplier_repository,
30         fuel_storage_repository,
31         purchase_repository,
32     ) -> None:
33         self.user_repository: UserRepository = user_repository
34         self.fuel_supplier_repository: FuelSupplierRepository = fuel_supplier_repository
35         self.fuel_storage_repository: FuelStorageRepository = fuel_storage_repository
36         self.purchase_repository: PurchaseRepository = purchase_repository
37 
38     async def get_suppliers(self, current_user: User) -> list[SupplierData]:
39         await self._validate_user_permissions(self.user_repository, current_user.id)
40 
41         suppliers = await self.fuel_supplier_repository.get_fuel_suppliers()
42         return [SupplierData(**supplier.__dict__) for supplier in suppliers]
43 
44     async def create_supplier(
45         self, data: SupplierBase, current_user: User
46     ) -> SupplierData:
47         await self._validate_user_permissions(self.user_repository, current_user.id)
48 
49         try:
50             new_supplier: FuelSupplier = (
51                 await self.fuel_supplier_repository.create_fuel_supplier(data)
52             )
53             return SupplierData(**new_supplier.__dict__)
54         except IntegrityError:
55             raise HTTPException(
56                 status.HTTP_409_CONFLICT,
57                 detail=error_wrapper(
58                     "Fuel supplier with this title already exists", "title"
59                 ),
60             )
61 
62     async def update_supplier(
63         self, supplier_id: int, data: SupplierUpdate, current_user: User
64     ) -> SupplierData:
65         await self._validate_user_permissions(self.user_repository, current_user.id)
66         await self._validate_instance_exists(self.fuel_supplier_repository, supplier_id)
67 
68         try:
69             updated_supplier: FuelSupplier = (
70                 await self.fuel_supplier_repository.update_fuel_supplier(
71                     supplier_id, data
72                 )
73             )
74             return SupplierData(**updated_supplier.__dict__)
75         except IntegrityError:
76             raise HTTPException(
77                 status.HTTP_409_CONFLICT,
78                 detail=error_wrapper(
79                     "Fuel supplier with this title already exists", "title"
80                 ),
81             )
82 
83     async def delete_supplier(self, supplier_id: int, current_user: User) -> None:
84         await self._validate_user_permissions(self.user_repository, current_user.id)
85         await self._validate_instance_exists(self.fuel_supplier_repository, supplier_id)
86 
87         await self.fuel_supplier_repository.delete_fuel_supplier(supplier_id)
88 
89     async def get_storages(self, current_user: User) -> list[StorageData]:
90         await self._validate_user_permissions(self.user_repository, current_user.id)
91 
92         storages = await self.fuel_storage_repository.get_fuel_storages()
93         return [StorageData(**storage.__dict__) for storage in storages]
94 
95     async def create_storage(
96         self, data: StorageBase, current_user: User
97     ) -> StorageData:
98         await self._validate_user_permissions(self.user_repository, current_user.id)
99 
100        new_storage: FuelStorage = (
101            await self.fuel_storage_repository.create_fuel_storage(data)
102        )
103        return StorageData(**new_storage.__dict__)
104 
105    async def update_storage(
106        self, storage_id: int, data: StorageUpdate, current_user: User
107    ) -> SupplierData:
108        await self._validate_user_permissions(self.user_repository, current_user.id)
109        await self._validate_instance_exists(self.fuel_storage_repository, storage_id)
110 
111        updated_storage: FuelStorage = (
112            await self.fuel_storage_repository.update_fuel_storage(storage_id, data)
113        )
114        return StorageData(**updated_storage.__dict__)
115 
116    async def delete_storage(self, storage_id: int, current_user: User) -> None:
117        await self._validate_user_permissions(self.user_repository, current_user.id)
118        await self._validate_instance_exists(self.fuel_storage_repository, storage_id)
119 
120        await self.fuel_storage_repository.delete_fuel_storage(storage_id)
121 
122    async def get_purchases(self, current_user: User) -> list[PurchaseData]:
123        await self._validate_user_permissions(self.user_repository, current_user.id)
124 
125        purchases = await self.purchase_repository.get_purchases()
126        return [PurchaseData(**purchase.__dict__) for purchase in purchases]
127 
128    async def create_purchase(
129        self, data: PurchaseBase, current_user: User
130    ) -> PurchaseData:
131        await self._validate_user_permissions(self.user_repository, current_user.id)
132 
133        fuel_storage: FuelStorage = await self.fuel_storage_repository.get_fuel_storage(
134            data.fuel_storage_id
135        )
136 
137        fuel_supplier: FuelSupplier = await self.fuel_supplier_repository.get_fuel_supplier(data.fuel_supplier_id)
138        if fuel_supplier.fuel_type != fuel_storage.fuel_type:
139            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Type of fuel doesn't match for the storage and supplier")
140 
141        allowed_amount: float = fuel_storage.max_amount - fuel_storage.current_amount
142        if data.amount > allowed_amount:
143            raise HTTPException(
144                status.HTTP_400_BAD_REQUEST,
145                f"You can't put that much fuel in. Maximum permissible value is {allowed_amount}",
146            )
147 
148        fuel_storage.current_amount += data.amount
149        await self.fuel_storage_repository.save(fuel_storage)
150        
151        new_purchase: Purchase = await self.purchase_repository.create_purchase(
152            PurchaseCreate(**data.model_dump(), user_id=current_user.id)
153        )
154        print(new_purchase)
155        return PurchaseData(**new_purchase.__dict__)


        А.5 Код базового сервісу


1  from typing import Optional
2  
3  from fastapi import HTTPException, status
4  from pydantic import BaseModel
5  
6  from app.config.logs.logger import logger
7  from app.models.db.user import UserRoles
8  from app.repository.base import BaseRepository
9  from app.repository.user import UserRepository
10 from app.utilities.formatters.http_error import error_wrapper
11 
12 
13 class BaseService:
14     async def _validate_instance_exists(
15         self, repository: BaseRepository, instance_id: int
16     ) -> None:
17         if not await repository.exists_by_id(instance_id):
18             raise HTTPException(
19                 status.HTTP_404_NOT_FOUND,
20                 detail=f"{repository.model.__name__} is not found",
21             )
22 
23     def _validate_update_data(self, update_data: BaseModel) -> None:
24         new_fields: dict = update_data.model_dump(exclude_none=True)
25         if new_fields == {}:
26             logger.warning("Validation error: No parameters have been provided")
27             raise HTTPException(
28                 status.HTTP_400_BAD_REQUEST,
29                 detail=error_wrapper(
30                     "At least one valid field should be provided", None
31                 ),
32             )
33 
34     async def _validate_user_permissions(
35         self,
36         user_repository: UserRepository,
37         user_id: int,
38         role: Optional[UserRoles] = UserRoles.ADMIN,
39         raise_exception: bool = True,
40     ) -> None:
41         user = await user_repository.get_user_by_id(user_id)
42         if user.role != role and raise_exception:
43             raise HTTPException(status.HTTP_403_FORBIDDEN, detail="Forbidden")


        А.6 Модуль отримання об’єктів сервісів через Dependency Injection


1  from fastapi import Depends
2  
3  from app.api.dependencies.repository import get_repository
4  from app.repository.fuel_storage import FuelStorageRepository
5  from app.repository.fuel_supplier import FuelSupplierRepository
6  from app.repository.inspection import InspectionRepository
7  from app.repository.purchase import PurchaseRepository
8  from app.repository.shift import ShiftRepository
9  from app.repository.user import UserRepository
10 from app.repository.vehicle import VehicleRepository
11 from app.services.fuel import FuelService
12 from app.services.shift import ShiftService
13 from app.services.user import UserService
14 from app.services.vehicle import VehicleService
15 
16 
17 def get_user_service(
18     user_repository: UserRepository = Depends(get_repository(UserRepository)),
19 ) -> UserService:
20     service = UserService(user_repository)
21     return service
22 
23 
24 def get_vehicle_service(
25     user_repository: UserRepository = Depends(get_repository(UserRepository)),
26     vehicle_repository: VehicleRepository = Depends(get_repository(VehicleRepository)),
27     shift_repository: ShiftRepository = Depends(get_repository(ShiftRepository)),
28     inspection_repository: InspectionRepository = Depends(
29         get_repository(InspectionRepository)
30     ),
31 ) -> VehicleService:
32     service = VehicleService(
33         user_repository, vehicle_repository, shift_repository, inspection_repository
34     )
35     return service
36 
37 
38 def get_shift_service(
39     user_repository: UserRepository = Depends(get_repository(UserRepository)),
40     shift_repository: ShiftRepository = Depends(get_repository(ShiftRepository)),
41     vehicle_repository: VehicleRepository = Depends(get_repository(VehicleRepository)),
42 ) -> ShiftService:
43     service = ShiftService(user_repository, shift_repository, vehicle_repository)
44     return service
45 
46 
47 def get_fuel_service(
48     user_repository: UserRepository = Depends(get_repository(UserRepository)),
49     fuel_supplier_repository: FuelSupplierRepository = Depends(
50         get_repository(FuelSupplierRepository)
51     ),
52     fuel_storage_repository: FuelStorageRepository = Depends(
53         get_repository(FuelStorageRepository)
54     ),
55     purchase_repository: PurchaseRepository = Depends(
56         get_repository(PurchaseRepository)
57     ),
58 ) -> FuelService:
59     service = FuelService(
60         user_repository,
61         fuel_supplier_repository,
62         fuel_storage_repository,
63         purchase_repository,
64     )
65     return service


        А.7 Базовий репозиторій


1  from itertools import chain
2  from typing import Any, Iterable, Type
3  
4  from pydantic import BaseModel
5  from sqlalchemy import delete, select, update
6  from sqlalchemy.ext.asyncio import AsyncSession
7  from sqlalchemy.sql import Select
8  
9  from app.core.database import Base
10 
11 
12 class BaseRepository:
13     model: Any = None
14 
15     def __init__(self, async_session: AsyncSession):
16         self.async_session = async_session
17 
18     def unpack(self, collection: Iterable) -> list:
19         return list(chain.from_iterable(collection))
20 
21     async def create(self, model_data: Type[BaseModel], *args, **kwargs) -> Type[Base]:
22         new_instance = self.model(**model_data.model_dump(), **kwargs)
23         self.async_session.add(new_instance)
24 
25         await self.async_session.commit()
26         return new_instance
27 
28     async def exists(self, query: Select) -> bool:
29         query = query.with_only_columns(self.model.id)
30         response = await self.async_session.execute(query)
31 
32         result = response.first()
33         return bool(result)
34 
35     async def exists_by_id(self, instance_id: int) -> bool:
36         query = select(self.model).where(self.model.id == instance_id)
37         return await self.exists(query)
38 
39     async def get_many(self, query: Select) -> list[Any]:
40         response = await self.async_session.execute(query)
41         result = response.unique().all()
42         return result
43 
44     async def get_instance(self, query: Select) -> Base:
45         response = await self.async_session.execute(query)
46         result = response.unique().scalar_one_or_none()
47         return result
48 
49     async def update(self, instance_id: int, model_data: Type[BaseModel]) -> Type[Base]:
50         query = (
51             update(self.model)
52             .where(self.model.id == instance_id)
53             .values(
54                 {
55                     key: value
56                     for key, value in model_data.model_dump().items()
57                     if value is not None
58                 }
59             )
60             .returning(self.model)
61         )
62         res = await self.async_session.execute(query)
63         await self.async_session.commit()
64         return res.unique().scalar_one()
65 
66     async def delete(self, instance_id: int) -> int:
67         query = (
68             delete(self.model)
69             .where(self.model.id == instance_id)
70             .returning(self.model.id)
71         )
72 
73         result = (await self.async_session.execute(query)).scalar_one()
74         await self.async_session.commit()
75         return result
76 
77     async def save(self, obj: Any):
78         self.async_session.add(obj)
79         await self.async_session.commit()
80 
81     async def save_many(self, objects: list[Any]):
82         self.async_session.add_all(objects)
83         await self.async_session.commit()




Додаток Б Програмний код IoT пристрою
Б.1 Код головного модуля main.py
1  from typing import Optional
2  
3  from api_fetch import get_storages_ids
4  from auth import authenticate_iot
5  from services import refuel_critical, refuel_regular
6  
7  
8  def _ask_storage_id() -> Optional[int]:
9      storage_id: int = int(input("Enter fuel storage_id:"))
10     available_ids: list[int] = get_storages_ids()
11 
12     if storage_id not in available_ids:
13         print("Wrong storage id")
14         return None
15     
16     return storage_id
17 
18 
19 def main() -> None:
20     authenticate_iot()
21 
22     try:
23         scenario: int = int(
24             input(
25                 'If you want to start a refuel to critical amount enter "1"\nIf you want to refuel to a specific amount enter "2":'
26             )
27         )
28 
29         if scenario not in [1, 2]:
30             print("Only 1 and 2 are allowed")
31             return
32 
33         if scenario == 1:
34             storage_id = _ask_storage_id()
35             if storage_id:
36                 refuel_critical(storage_id)
37         else:
38             storage_id = _ask_storage_id()
39             fuel_amount: int = int(input("Enter fuel amount:"))
40             if storage_id:
41                 refuel_regular(storage_id, fuel_amount)
42 
43     except ValueError:
44         print("Value should be an integer")
45 
46 
47 if __name__ == "__main__":
48     main()


Б.2 Код модуля services.py


1  from time import sleep
2  
3  from tqdm import tqdm
4  
5  from api_fetch import get_storage_critical_lvl, get_storage_current_lvl, send_current_fuel_lvl, send_critical_message
6  
7  
8  def refuel_critical(storage_id: int) -> None:
9      critical_lvl: int = get_storage_critical_lvl(storage_id)
10     current_lvl: int = get_storage_current_lvl(storage_id)
11 
12     steps: int = int(current_lvl // 50)
13 
14     print("Start refueling the vehicle")
15     for _ in tqdm(range(steps)):
16         current_lvl -= 50
17         send_current_fuel_lvl(storage_id, current_lvl)
18         sleep(0.2)
19 
20         if current_lvl <= critical_lvl:
21             send_critical_message(storage_id)
22             print("Critical amount message was sent to administrator")
23             break
24 
25     print("Refueling is over")
26 
27 
28 def refuel_regular(storage_id: int, fuel_amount: float) -> None:
29     print("Start refueling the vehicle")
30     current_lvl: int = get_storage_current_lvl(storage_id)
31     send_current_fuel_lvl(storage_id, current_lvl - fuel_amount)
32     print("Refueling is over")


Б.3 Код модуля auth.py


1  import requests
2  
3  from config import get_auth_creds, get_base_url, get_jwt, set_jwt
4  
5  BASE_URL: str = get_base_url()
6  
7  
8  def authenticate_iot(force: bool = False) -> None:
9      jwt: str = get_jwt()
10     if not jwt or force:
11         auth_data: dict[str, str] = get_auth_creds()
12         try:
13             response = requests.post(
14                 f"{BASE_URL}/auth/login/",
15                 json={"email": auth_data["email"], "password": auth_data["password"]},
16             )
17             if response.status_code != 200:
18                 print("Server-side error, try later")
19                 return
20 
21             jwt = (response.json())["token"]
22             set_jwt(jwt)
23         except requests.ConnectionError as e:
24             print("Error while authenticating the device")


Б.4 Код модуля config.py


1  import json
2  
3  STORAGE_FILE_NAME: str = "local_storage.json"
4  
5  
6  def get_base_url() -> str:
7      with open(STORAGE_FILE_NAME, "r", encoding="utf-8") as file:
8          data: dict = json.loads(file.read())
9          return data["base_url"]
10 
11 
12 def get_jwt() -> str:
13     with open(STORAGE_FILE_NAME, "r", encoding="utf-8") as file:
14         data: dict = json.loads(file.read())
15         return data["jwt"]
16 
17 
18 def get_auth_creds() -> dict[str, str]:
19     with open(STORAGE_FILE_NAME, "r", encoding="utf-8") as file:
20         data: dict = json.loads(file.read())
21         return {"email": data["device_email"], "password": data["device_password"]}
22 
23 
24 def set_jwt(token: str) -> None:
25     with open(STORAGE_FILE_NAME, "r", encoding="utf-8") as file:
26         current_data: dict = json.loads(file.read())
27         current_data["jwt"] = token
28 
29     with open(STORAGE_FILE_NAME, "w", encoding="utf-8") as file:
30         json.dump(current_data, file, ensure_ascii=False, indent=4)


Б.5 Код модуля api_fetch.py


1  from dataclasses import dataclass
2  from typing import Any
3  
4  import requests
5  
6  from config import get_base_url, get_jwt
7  
8  JWT: str = get_jwt()
9  BASE_URL: str = get_base_url()
10 
11 
12 @dataclass
13 class Storage:
14     max_amount: int
15     critical_amount: int
16     fuel_type: str
17     id: int
18     current_amount: float
19 
20 
21 def get_storages() -> list[Storage]:
22     response = requests.get(
23         f"{BASE_URL}/fuel/storages/", headers={"Authorization": f"Bearer {JWT}"}
24     )
25     return response.json()
26 
27 
28 def get_storages_ids() -> list[int]:
29     storages: list[Storage] = get_storages()
30     return [storage["id"] for storage in storages]
31 
32 
33 def get_storage_critical_lvl(storage_id: int) -> int:
34     storages: list[Storage] = get_storages()
35     for storage in storages:
36         if storage["id"] == storage_id:
37             return storage["critical_amount"]
38 
39 
40 def get_storage_current_lvl(storage_id: int) -> int:
41     storages: list[Storage] = get_storages()
42     for storage in storages:
43         if storage["id"] == storage_id:
44             return storage["current_amount"]
45 
46 
47 def send_current_fuel_lvl(storage_id: int, current_lvl: float) -> None:
48     requests.patch(
49         f"{BASE_URL}/fuel/storages/{storage_id}/update",
50         json={"current_amount": current_lvl},
51         headers={"Authorization": f"Bearer {JWT}"},
52     )
53 
54 def send_critical_message(storage_id: int) -> None:
55     requests.post(
56         f"{BASE_URL}/admin/send-critical-messages/",
57         json={"storage_id": storage_id, "message": f"Storage {storage_id} requires fuel purchase"},
58         headers={"Authorization": f"Bearer {JWT}"},
59     )




Додаток В Результат перевірки роботи на антиплагіат